# Stage 1: Build C++ Crypto Library
FROM ubuntu:22.04 AS cpp-builder

RUN apt-get update && apt-get install -y \
    build-essential \
    cmake \
    libssl-dev \
    git

WORKDIR /app/crypto_cpp
COPY crypto_cpp/ .

RUN mkdir build && cd build && \
    cmake .. && \
    make && \
    make install

# Stage 2: Build Go Application
FROM golang:1.22 AS go-builder

# Install C++ lib dependencies for linking time
COPY --from=cpp-builder /usr/local/lib/libpaycrypto.so /usr/local/lib/
COPY --from=cpp-builder /usr/local/include/paycrypto.h /usr/local/include/

# Update ld cache
RUN ldconfig

WORKDIR /app

# Dependencies
COPY go.mod go.sum* ./
RUN go mod download

# Source code
COPY . .

# Build Worker (simulating a separate binary if main.go supports it or separate file)
# Ideally there's a cmd/worker/main.go or cmd/server/main.go takes a flag
# For now, let's assume we might reuse the server binary with a different command or build a separate one if it exists
# Blueprint implies 'cmd/server/main.go' only in structure, but 'worker' service in compose command: /worker
# Let's create a cmd/worker if strictly following separate Dockerfile, 
# OR use the same binary with a 'worker' subcommand. 
# The blueprint folder structure shows `cmd/server/main.go`, doesn't explicitly show `cmd/worker`. 
# BUT `docker-compose.yml` says `command: /worker` (or similar) in the USER prompt description (section 10).
# Actually section 10 says `command: /worker` for the worker service. 
# And generic build `build: ../`.
# I will implement `cmd/worker/main.go` to be safe and clear.

RUN CGO_ENABLED=1 go build -o paylink-worker ./cmd/worker

# Stage 3: Runtime
FROM ubuntu:22.04

RUN apt-get update && apt-get install -y \
    libssl-dev \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

COPY --from=cpp-builder /usr/local/lib/libpaycrypto.so /usr/lib/libpaycrypto.so
RUN ldconfig

COPY --from=go-builder /app/paylink-worker /app/paylink-worker
COPY .env.example /app/.env

RUN useradd -m paylink
USER paylink

CMD ["/app/paylink-worker"]
